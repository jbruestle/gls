#
# The GSL OCL Code Generator
# Tim Carstens Winter 13-14
#

require 'fileutils'

Out_dir_ocl_ul = "../include/ocl/ul"
Out_dir_test = "../tests/ocl"
Out_dir_test_ocl = "#{Out_dir_test}/include/ocl"
Out_dir_las = "../las/"

class HostLasGenerator
  def initialize(bitwidth)
    @bw = bitwidth
    @ul = "ul#{@bw}"
    
    @out_fname = "#{Out_dir_las}/ocl_process_#{@ul}.c"
  end
  
  def say(s)
    @outFile.write("#{s}\n")
  end
  
  def genAll
    @outFile = File.open(@out_fname, 'w')
    puts "Generating #{@out_fname}"
    say "/*"
    say " * AUTOGENERATED tcarstens January 2014"
    say " */"
    say "#define BITSIZE            (#{@bw})"
    say ""
    say ""
    say "#define ul_ocl             ocl_#{@ul}"
    say "#define ul_init_ocl        ocl_#{@ul}_init"
    say "#define ul_clear_ocl       ocl_#{@ul}_clear"
    say "#define mpz_set_ul_ocl     mpz_set_ocl_#{@ul}"
    say "#define mpz_get_ul_ocl     mpz_get_ocl_#{@ul}"
    say ""
    say ""
    say "#define pm1_process_ocl    pm1_#{@ul}_process_ocl"
    say "#define kern_pm1_stage1    \"kern_pm1_#{@ul}_stage1\""
    say "#define kern_pm1_reorder   \"kern_pm1_#{@ul}_reorder\""
    say "#define kern_pm1_stage2    \"kern_pm1_#{@ul}_stage2\""
    say ""
    say "#define pp1_process_ocl    pp1_#{@ul}_process_ocl"
    say "#define kern_pp1_stage1    \"kern_pp1_#{@ul}_stage1\""
    say "#define kern_pp1_reorder   \"kern_pp1_#{@ul}_reorder\""
    say "#define kern_pp1_stage2    \"kern_pp1_#{@ul}_stage2\""
    say ""
    say "#define ecm_process_ocl    ecm_#{@ul}_process_ocl"
    say "#define kern_ecm_stage1    \"kern_ecm_#{@ul}_stage1\""
    say "#define kern_ecm_reorder   \"kern_ecm_#{@ul}_reorder\""
    say "#define kern_ecm_stage2    \"kern_ecm_#{@ul}_stage2\""
    say ""
    say ""
    say "#define ellM_point_t       ellM#{@bw}_point_t"
    say "#define mod                mod#{@bw}"
    say "#define ul                 ul#{@bw}"
    say "#define ul_init            ul#{@bw}_init"
    say "#define ul_clear           ul#{@bw}_clear"
    say "#define ul_set_ui          ul#{@bw}_set_ui"
    say "#define ul_cmp_ui          ul#{@bw}_cmp_ui"
    say "#define ul_cmp             ul#{@bw}_cmp"
    say "#define mod_init           mod#{@bw}_init"
    say "#define mod_clear          mod#{@bw}_clear"
    say "#define mod_set            mod#{@bw}_set"
    say "#define mpz_get_ul         mpz_get_ul#{@bw}"
    say "#define mpz_set_ul         mpz_set_ul#{@bw}"
    say "#define pm1_stage1_ul      pm1_stage1_ul#{@bw}"
    say "#define pm1_stage2_ul      pm1_stage2_ul#{@bw}"
    say "#define pp1_stage1_ul      pp1_stage1_ul#{@bw}"
    say "#define pp1_stage2_ul      pp1_stage2_ul#{@bw}"
    say "#define ecm_stage1_ul      ecm_stage1_ul#{@bw}"
    say "#define ecm_stage2_ul      ecm_stage2_ul#{@bw}"
    say ""
    say ""
    say "#include \"ocl_process_common.h\""
  end
end

class OclLasGenerator
  def initialize(bitwidth)
    @bw = bitwidth
    @ul = "ul#{@bw}"
    @modul = "mod#{@bw}"

    @out_fname = "#{Out_dir_las}/ocl/las_#{@ul}.hl"
  end
  
  def say(s)
    @outFile.write("#{s}\n")
  end
  
  def genAll
    @outFile = File.open(@out_fname, 'w')
    say "/*"
    say " * AUTOGENERATED tcarstens January 2014"
    say " */"
    puts "Generating #{@out_fname}"
    say "#include \"../../include/ocl/ul/#{@ul}.hl\""
    say "#include \"kernels.hl\""
  end
end

class HostTestGenerator
  def initialize(bitwidth)
    @bw = bitwidth
    @ul = "ul#{@bw}"
    
    @out_fname = "#{Out_dir_test}/test_#{@ul}.c"
  end
  
  def say(s)
    @outFile.write("#{s}\n")
  end
  
  def genAll
    @outFile = File.open(@out_fname, 'w')
    puts "Generating #{@out_fname}"
    say "/*"
    say " * AUTOGENERATED tcarstens January 2014"
    say " */"
    say "#include \"tests.h\""
    say ""
    say ""
    say "#if TEST_SET & TEST_#{@bw}"
    say "#define mpz_set_ul  mpz_set_ocl_#{@ul}"
    say ""
    say "#define ul_bitsize  (#{@bw})"
    say "#define ul          ocl_#{@ul}"
    say ""
    say ""
    say "#define ul_test_all        #{@ul}_test_all"
    say "#define ul_test_setup      #{@ul}_test_setup"
    say "#define ul_test_clear      #{@ul}_test_clear"
    say "#define ul_test_run_kernel #{@ul}_test_run_kernel"
    say ""
    say "#define ul_rand_seed_two   \"kern_#{@ul}_rand_seed_two\""
    say "#define ul_rand_seed_three \"kern_#{@ul}_rand_seed_three\""
    say ""
    say "#define ul_binop_test      #{@ul}_binop_test"
    say "#define ul_add_test        \"kern_#{@ul}_add_test\""
    say "#define ul_sub_test        \"kern_#{@ul}_sub_test\""
    say "#define ul_mul_test        \"kern_#{@ul}_mul_test\""
    say ""
    say "#define ul_divremop_test   #{@ul}_divremop_test"
    say "#define ul_divrem_test     \"kern_#{@ul}_divrem_test\""
    say ""
    say "#define ul_compare_test    #{@ul}_compare_test"
    say "#define ul_cmp_test        \"kern_#{@ul}_cmp_test\""
    say "#define ul_cmp_ui_test     \"kern_#{@ul}_cmp_ui_test\""
    say ""
    say "#define ul_mod_binop_test  mod#{@bw}_binop_test"
    say "#define ul_mod_add_test    \"kern_mod#{@bw}_add_test\""
    say "#define ul_mod_sub_test    \"kern_mod#{@bw}_sub_test\""
    say "#define ul_mod_mul_test    \"kern_mod#{@bw}_mul_test\""
    say "#define ul_mod_mul_test2   \"kern_mod#{@bw}_mul_test2\""
    say "#define ul_mod_inv_test    \"kern_mod#{@bw}_inv_test\""
    say ""
    say ""
    say ""
    say "#define ul_pm1pp1_reorder      \"kern_#{@ul}_pm1pp1_reorder\""
    say ""
    say "#define ul_pm1op_test      #{@ul}_pm1op_test"
    say "#define ul_pm1_stage1      \"kern_#{@ul}_pm1_stage1\""
    say "#define ul_pm1_stage2      \"kern_#{@ul}_pm1_stage2\""
    say ""
    say "#define ul_pp1op_test      #{@ul}_pp1op_test"
    say "#define ul_pp1_stage1      \"kern_#{@ul}_pp1_stage1\""
    say "#define ul_pp1_stage2      \"kern_#{@ul}_pp1_stage2\""
    say ""
    say "#define ul_ecmop_test      #{@ul}_ecmop_test"
    say "#define ul_ecm_reorder     \"kern_#{@ul}_ecm_reorder\""
    say "#define ul_ecm_stage1      \"kern_#{@ul}_ecm_stage1\""
    say "#define ul_ecm_stage2      \"kern_#{@ul}_ecm_stage2\""
    say ""
    say ""
    say "#include \"test_all.h\""
    say "#endif /* TEST_#{@bw} */"
  end
end

class OclDefGenerator
  def initialize(bitwidth)
    @bw = bitwidth
    @ul = "ul#{@bw}"
    @modul = "mod#{@bw}"
    
    @out_fname = "#{Out_dir_ocl_ul}/#{@ul}_def.hl"
  end
  
  def say(s)
      @outFile.write("#{s}\n")
    end
  
  def genAll
    @outFile = File.open(@out_fname, 'w')
    puts "Generating #{@out_fname}"
    say "/*"
    say " * AUTOGENERATED tcarstens January 2014"
    say " */"
    say "#ifndef UL#{@bw}_DEF_H_"
    say "#define UL#{@bw}_DEF_H_"
    say ""
    say ""
    say "#undef ul"
    say "#define ul #{@ul}"
    say "#undef mod"
    say "#define mod #{@modul}"
    say ""
    say "#undef ul_init"
    say "#define ul_init #{@ul}_init"
    say "#undef ul_clear"
    say "#define ul_clear #{@ul}_clear"
    say ""
    say "#undef ul_set"
    say "#define ul_set #{@ul}_set"
    say "#undef ul_set_ui"
    say "#define ul_set_ui #{@ul}_set_ui"
    say "#undef ul_get_ui"
    say "#define ul_get_ui #{@ul}_get_ui"
    say "#undef ul_set_gp"
    say "#define ul_set_gp #{@ul}_set_gp"
    say "#undef ul_set_pg"
    say "#define ul_set_pg #{@ul}_set_pg"
    say "#undef ul_set_gg"
    say "#define ul_set_gg #{@ul}_set_gg"
    say "#undef ul_cmp"
    say "#define ul_cmp #{@ul}_cmp"
    say "#undef ul_cmp_ui"
    say "#define ul_cmp_ui #{@ul}_cmp_ui"
    say ""
    say "#undef ul_add"
    say "#define ul_add #{@ul}_add"
    say "#undef ul_sub"
    say "#define ul_sub #{@ul}_sub"
    say "#undef ul_mul"
    say "#define ul_mul #{@ul}_mul"
    say "#undef ul_divrem"
    say "#define ul_divrem #{@ul}_divrem"
    say ""
    say "#undef mod_init"
    say "#define mod_init #{@modul}_init"
    say "#undef mod_set"
    say "#define mod_set #{@modul}_set"
    say "#undef ul_to_montgomery"
    say "#define ul_to_montgomery #{@ul}_to_montgomery"
    say "#undef ul_from_montgomery"
    say "#define ul_from_montgomery #{@ul}_from_montgomery"
    say ""
    say "#undef ul_modadd"
    say "#define ul_modadd #{@ul}_modadd"
    say "#undef ul_modsub"
    say "#define ul_modsub #{@ul}_modsub"
    say "#undef ul_modmul"
    say "#define ul_modmul #{@ul}_modmul"
    say "#undef ul_modinv"
    say "#define ul_modinv #{@ul}_modinv"
    say ""
    say "#undef ul_rshift"
    say "#define ul_rshift #{@ul}_rshift"
    say ""
    say "#undef ul_rand"
    say "#define ul_rand #{@ul}_rand"
    say ""
    say "#undef ul_gcd"
    say "#define ul_gcd #{@ul}_gcd"
    say ""
    say "#undef ul_moddiv2"
    say "#define ul_moddiv2 #{@ul}_moddiv2"
    say "#undef ul_moddiv3"
    say "#define ul_moddiv3 #{@ul}_moddiv3"
    say "#undef ul_moddiv5"
    say "#define ul_moddiv5 #{@ul}_moddiv5"
    say "#undef ul_moddiv7"
    say "#define ul_moddiv7 #{@ul}_moddiv7"
    say "#undef ul_moddiv11"
    say "#define ul_moddiv11 #{@ul}_moddiv11"
    say "#undef ul_moddiv13"
    say "#define ul_moddiv13 #{@ul}_moddiv13"
    say ""
    say ""
    say "/* P-1 */"
    say "#undef kern_pm1_stage1"
    say "#define kern_pm1_stage1    kern_pm1_#{@ul}_stage1"
    say "#undef kern_pm1_reorder"
    say "#define kern_pm1_reorder   kern_pm1_#{@ul}_reorder"
    say "#undef kern_pm1_stage2"
    say "#define kern_pm1_stage2    kern_pm1_#{@ul}_stage2"
    say ""
    say "#undef pm1_stage1"
    say "#define pm1_stage1 #{@ul}_pm1_stage1"
    say ""
    say ""
    say "/* P+1 */"
    say "#undef kern_pp1_stage1"
    say "#define kern_pp1_stage1    kern_pp1_#{@ul}_stage1"
    say "#undef kern_pp1_reorder"
    say "#define kern_pp1_reorder   kern_pp1_#{@ul}_reorder"
    say "#undef kern_pp1_stage2"
    say "#define kern_pp1_stage2    kern_pp1_#{@ul}_stage2"
    say ""
    say "#undef pp1_add"
    say "#define pp1_add #{@ul}_pp1_add"
    say "#undef pp1_double"
    say "#define pp1_double #{@ul}_pp1_double"
    say "#undef mod_V_ul"
    say "#define mod_V_ul #{@ul}_mod_V_ul"
    say "#undef pp1_stage1_bc"
    say "#define pp1_stage1_bc #{@ul}_pp1_stage1_bc"
    say "#undef pp1_stage1"
    say "#define pp1_stage1 #{@ul}_pp1_stage1"
    say "#undef pp1_stage2"
    say "#define pp1_stage2 #{@ul}_pp1_stage2"
    say ""
    say ""
    say "/* ECM */"
    say "#undef kern_ecm_stage1"
    say "#define kern_ecm_stage1    kern_ecm_#{@ul}_stage1"
    say "#undef kern_ecm_reorder"
    say "#define kern_ecm_reorder   kern_ecm_#{@ul}_reorder"
    say "#undef kern_ecm_stage2"
    say "#define kern_ecm_stage2    kern_ecm_#{@ul}_stage2"
    say ""
    say "#undef ellM_point_t"
    say "#define ellM_point_t #{@ul}_ellM_point_t"
    say "#undef ellW_point_t"
    say "#define ellW_point_t #{@ul}_ellW_point_t"
    say "#undef ellM_init"
    say "#define ellM_init #{@ul}_ellM_init"
    say "#undef ellM_clear"
    say "#define ellM_clear #{@ul}_ellM_clear"
    say "#undef ellM_set"
    say "#define ellM_set #{@ul}_ellM_set"
    say "#undef ellM_swap"
    say "#define ellM_swap #{@ul}_ellM_swap"
    say "#undef ellM_double"
    say "#define ellM_double #{@ul}_ellM_double"
    say "#undef ellM_add"
    say "#define ellM_add #{@ul}_ellM_add"
    say "#undef ellM_mul_ul"
    say "#define ellM_mul_ul #{@ul}_ellM_mul_ul"
    say "#undef ellW_init"
    say "#define ellW_init #{@ul}_ellW_init"
    say "#undef ellW_clear"
    say "#define ellW_clear #{@ul}_ellW_clear"
    say "#undef ellW_set"
    say "#define ellW_set #{@ul}_ellW_set"
    say "#undef ellW_swap"
    say "#define ellW_swap #{@ul}_ellW_swap"
    say "#undef ellW_double"
    say "#define ellW_double #{@ul}_ellW_double"
    say "#undef ellW_add"
    say "#define ellW_add #{@ul}_ellW_add"
    say "#undef ellW_mul_ui"
    say "#define ellW_mul_ui #{@ul}_ellW_mul_ui"
    say "#undef ellM_interpret_bytecode"
    say "#define ellM_interpret_bytecode #{@ul}_ellM_interpret_bytecode"
    say "#undef Brent12_curve_from_sigma"
    say "#define Brent12_curve_from_sigma #{@ul}_Brent12_curve_from_sigma"
    say "#undef Montgomery12_curve_from_k"
    say "#define Montgomery12_curve_from_k #{@ul}_Montgomery12_curve_from_k"
    say "#undef Montgomery16_curve_from_k"
    say "#define Montgomery16_curve_from_k #{@ul}_Montgomery16_curve_from_k"
    say "#undef curveW_from_Montgomery"
    say "#define curveW_from_Montgomery #{@ul}_curveW_from_Montgomery"
    say "#undef common_z"
    say "#define common_z #{@ul}_common_z"
    say "#undef ecm_stage2"
    say "#define ecm_stage2 #{@ul}_ecm_stage2"
    say "#undef ecm_stage1"
    say "#define ecm_stage1 #{@ul}_ecm_stage1"
    say ""
    say "#endif /* UL#{@bw}_DEF_H_ */"
    say ""
    
    @outFile.close
  end
end

class OclTestGenerator
  def initialize(bitwidth)
    @bw = bitwidth
    @ul = "ul#{@bw}"
    @modul = "mod#{@bw}"
    
    @out_fname = "#{Out_dir_test_ocl}/#{@ul}_test.hl"
  end
  
  def say(s)
      @outFile.write("#{s}\n")
    end
  
  def genAll
    @outFile = File.open(@out_fname, 'w')
    puts "Generating #{@out_fname}"
    say "/*"
    say " * AUTOGENERATED tcarstens January 2014"
    say " */"
    say "#include \"../../../../include/ocl/ul/#{@ul}.hl\""
    say "#include \"../../../../include/ocl/ul/#{@ul}_def.hl\""
    say ""
    say "#undef limbs"
    say "#define limbs #{@bw / 32}"
    say ""
    say ""
    say "#undef kern_ul_rand_seed_two"
    say "#define kern_ul_rand_seed_two kern_#{@ul}_rand_seed_two"
    say "#undef kern_ul_rand_seed_three"
    say "#define kern_ul_rand_seed_three kern_#{@ul}_rand_seed_three"
    say ""
    say "#undef kern_ul_add_test"
    say "#define kern_ul_add_test kern_#{@ul}_add_test"
    say "#undef kern_ul_sub_test"
    say "#define kern_ul_sub_test kern_#{@ul}_sub_test"
    say "#undef kern_ul_mul_test"
    say "#define kern_ul_mul_test kern_#{@ul}_mul_test"
    say "#undef kern_ul_divrem_test"
    say "#define kern_ul_divrem_test kern_#{@ul}_divrem_test"
    say ""
    say "#undef kern_ul_cmp_test"
    say "#define kern_ul_cmp_test kern_#{@ul}_cmp_test"
    say "#undef kern_ul_cmp_ui_test"
    say "#define kern_ul_cmp_ui_test kern_#{@ul}_cmp_ui_test"
    say ""
    say "#undef kern_mod_add_test"
    say "#define kern_mod_add_test kern_#{@modul}_add_test"
    say "#undef kern_mod_sub_test"
    say "#define kern_mod_sub_test kern_#{@modul}_sub_test"
    say "#undef kern_mod_mul_test"
    say "#define kern_mod_mul_test kern_#{@modul}_mul_test"
    say "#undef kern_mod_mul_test2"
    say "#define kern_mod_mul_test2 kern_#{@modul}_mul_test2"
    say "#undef kern_mod_inv_test"
    say "#define kern_mod_inv_test kern_#{@modul}_inv_test"
    say ""
    say ""
    say "#undef kern_pm1pp1_reorder"
    say "#define kern_pm1pp1_reorder kern_#{@ul}_pm1pp1_reorder"
    say ""
    say ""
    say "/* P-1 */"
    say "#undef kern_pm1_stage1"
    say "#define kern_pm1_stage1 kern_#{@ul}_pm1_stage1"
    say "#undef kern_pm1_stage2"
    say "#define kern_pm1_stage2 kern_#{@ul}_pm1_stage2"
    say ""
    say "#undef pm1_stage1"
    say "#define pm1_stage1 #{@ul}_pm1_stage1"
    say ""
    say ""
    say "/* P+1 */"
    say "#undef kern_pp1_stage1"
    say "#define kern_pp1_stage1 kern_#{@ul}_pp1_stage1"
    say "#undef kern_pp1_stage2"
    say "#define kern_pp1_stage2 kern_#{@ul}_pp1_stage2"
    say ""
    say "#undef pp1_add"
    say "#define pp1_add #{@ul}_pp1_add"
    say "#undef pp1_double"
    say "#define pp1_double #{@ul}_pp1_double"
    say "#undef mod_V_ul"
    say "#define mod_V_ul #{@ul}_mod_V_ul"
    say "#undef pp1_stage1_bc"
    say "#define pp1_stage1_bc #{@ul}_pp1_stage1_bc"
    say "#undef pp1_stage1"
    say "#define pp1_stage1 #{@ul}_pp1_stage1"
    say "#undef pp1_stage2"
    say "#define pp1_stage2 #{@ul}_pp1_stage2"
    say ""
    say ""
    say "/* ECM */"
    say "#undef kern_ecm_reorder"
    say "#define kern_ecm_reorder kern_#{@ul}_ecm_reorder"
    say "#undef kern_ecm_stage1"
    say "#define kern_ecm_stage1 kern_#{@ul}_ecm_stage1"
    say "#undef kern_ecm_stage2"
    say "#define kern_ecm_stage2 kern_#{@ul}_ecm_stage2"
    say ""
    say "#undef ellM_point_t"
    say "#define ellM_point_t #{@ul}_ellM_point_t"
    say "#undef ellW_point_t"
    say "#define ellW_point_t #{@ul}_ellW_point_t"
    say "#undef ellM_init"
    say "#define ellM_init #{@ul}_ellM_init"
    say "#undef ellM_clear"
    say "#define ellM_clear #{@ul}_ellM_clear"
    say "#undef ellM_set"
    say "#define ellM_set #{@ul}_ellM_set"
    say "#undef ellM_swap"
    say "#define ellM_swap #{@ul}_ellM_swap"
    say "#undef ellM_double"
    say "#define ellM_double #{@ul}_ellM_double"
    say "#undef ellM_add"
    say "#define ellM_add #{@ul}_ellM_add"
    say "#undef ellM_mul_ul"
    say "#define ellM_mul_ul #{@ul}_ellM_mul_ul"
    say "#undef ellW_init"
    say "#define ellW_init #{@ul}_ellW_init"
    say "#undef ellW_clear"
    say "#define ellW_clear #{@ul}_ellW_clear"
    say "#undef ellW_set"
    say "#define ellW_set #{@ul}_ellW_set"
    say "#undef ellW_swap"
    say "#define ellW_swap #{@ul}_ellW_swap"
    say "#undef ellW_double"
    say "#define ellW_double #{@ul}_ellW_double"
    say "#undef ellW_add"
    say "#define ellW_add #{@ul}_ellW_add"
    say "#undef ellW_mul_ui"
    say "#define ellW_mul_ui #{@ul}_ellW_mul_ui"
    say "#undef ellM_interpret_bytecode"
    say "#define ellM_interpret_bytecode #{@ul}_ellM_interpret_bytecode"
    say "#undef Brent12_curve_from_sigma"
    say "#define Brent12_curve_from_sigma #{@ul}_Brent12_curve_from_sigma"
    say "#undef Montgomery12_curve_from_k"
    say "#define Montgomery12_curve_from_k #{@ul}_Montgomery12_curve_from_k"
    say "#undef Montgomery16_curve_from_k"
    say "#define Montgomery16_curve_from_k #{@ul}_Montgomery16_curve_from_k"
    say "#undef curveW_from_Montgomery"
    say "#define curveW_from_Montgomery #{@ul}_curveW_from_Montgomery"
    say "#undef common_z"
    say "#define common_z #{@ul}_common_z"
    say "#undef ecm_stage2"
    say "#define ecm_stage2 #{@ul}_ecm_stage2"
    say "#undef ecm_stage1"
    say "#define ecm_stage1 #{@ul}_ecm_stage1"
    say ""
    say "#include \"../../../../include/ocl/cofact/cofact_plan.hl\""
    say "#include \"ul_test.hl\""
    say ""
    @outFile.close
  end
end

class OclHeaderGenerator
  def initialize(bitwidth, incl_higher)
    @bw = bitwidth
    @ul = "ul#{@bw}"
    @out_fname = "#{Out_dir_ocl_ul}/#{@ul}.hl"
    @incl_higher = incl_higher
  end
  
  def say(s)
    @outFile.write("#{s}\n")
  end
  
  def genAll
    @outFile = File.open(@out_fname, 'w')
    puts "Generating #{@out_fname}"
    say "/*"
    say " * AUTOGENERATED tcarstens January 2014"
    say " */"
    say "#ifndef UL#{@bw}_T_H__"
    say "#define UL#{@bw}_T_H__"
    say ""
    say "#include \"#{@ul}_0.hl\""
    if @incl_higher
      say "#include \"#{@ul}_1.hl\""
      say ""
      say "#include \"#{@ul}_def.hl\""
      say "#include \"ul_common.hl\""
    end
    say ""
    say "#endif /* UL#{@bw}_T_H__ */"
    say ""
    @outFile.close
  end
end

class OclBaseGenerator
  def initialize(bitwidth)
    @bw = bitwidth
    @limbs = bitwidth/32

    raise "Requires @bitwidth = #{@bw} be divisible by 32" unless (@bw % 32) == 0
    
    @ul    = "ul#{@bw}"
    @modul = "mod#{@bw}"
    
    @flag_nvidia = "UL_NVIDIA"
    
    @out_fname = "#{Out_dir_ocl_ul}/#{@ul}_0.hl"
    
    @indent = [0]
  end
  
  def pushi(i)
    @indent.push(@indent.last + i)
  end
  
  def popi
    @indent.pop
  end
  
  def say(s)
    ind = " " * @indent.last
    @outFile.write("#{ind}#{s}\n")
  end
  
  def vspace
    say("")
    say("")
    say("")
  end
  
  def comment(c)
    say "/*"
    say " * #{c}"
    say " */"
  end
  
  def gen_type
    comment @ul
    # Array style
    # say "typedef uint32_t ul#{@bitwidth}[#{@limbs}];"
    say "typedef struct #{@ul}_s {"
    pushi(4)
      say "uint32_t x[#{@limbs}];"
    popi
    say "} #{@ul}[1];"
    say ""
    say "inline void #{@ul}_init(#{@ul} x) { return; }"
    say "inline void #{@ul}_clear(#{@ul} x) { return; }"
    say ""
    say "typedef struct #{@modul}_s {"
    pushi(4)
      say "#{@ul} n;"
      say "uint32_t np;"
      say "#{@ul} rsq;"
    popi
    say "} #{@modul}[1];"
    say ""
  end
  
  def gen_setters
    prototypes = [ "inline void #{@ul}_set_gp(__global #{@ul} dst, #{@ul} src)",
                   "inline void #{@ul}_set_pg(#{@ul} dst, __global #{@ul} src)",
                   "inline void #{@ul}_set_gg(__global #{@ul} dst, __global #{@ul} src)",
                   "inline void #{@ul}_set(#{@ul} dst, #{@ul} src)"
                 ]
    comment "Setters"
    prototypes.each do |p|
      say "#{p} {"
      pushi(4)
      @limbs.times do |n|
        say "dst->x[#{n}] = src->x[#{n}];"
      end
      popi
      say "}"
    end
  end
  
  def gen_set_ui
    comment "Set a #{@ul} to a uint32_t"
    say "inline void #{@ul}_set_ui(#{@ul} dst, uint32_t i) {"
    pushi(4)
      @limbs.times do |j|
        if j == 0
          say "dst->x[#{j}] = i;"
        else
          say "dst->x[#{j}] = 0;"
        end
      end
    popi
    say "}"
    say ""
  end

  def gen_get_ui
    comment "Get a uint32_t out of a #{@ul}"
    say "inline uint32_t #{@ul}_get_ui(#{@ul} src) {"
    say "    return src->x[0];"
    say "}"
    say ""
  end
  
  def gen_rand
    comment "Generate a random #{@ul}"
    say "inline void #{@ul}_rand(struct rng_t *r, #{@ul} dst) {"
    pushi(4)
    (@limbs/2.0).ceil.times do |k|
      say "uint64_t w#{k} = rand_uint64(r);"
    end
    say ""
    @limbs.times do |n|
      k = (n/2.0).floor
      if n.even?
        fix = "& 0xffffffff"
      else
        fix = " >> 32"
      end
      say "dst->x[#{n}] = w#{k} #{fix};"
    end
    popi
    say "}"
  end
  
  def gen_add
    comment "Add two #{@ul}'s"
    say "inline void #{@ul}_add(#{@ul} dst, #{@ul} src1, #{@ul} src2) {"
    pushi(4)
      say "#if defined(#{@flag_nvidia})"
      pushi(4)
        say "asm("
        pushi(2)
          # We have 3*@limbs arguments into our inline assembly.
          if @bitwidth == 32
            say "\"add.u32  %#{0+0*@limbs}, %#{0+1*@limbs}, %#{0+2*@limbs};\\n\\t\""
          else
            say "\"add.cc.u32  %#{0+0*@limbs}, %#{0+1*@limbs}, %#{0+2*@limbs};\\n\\t\""
            (1..@limbs-2).each do |n|
              say "\"addc.cc.u32 %#{n+0*@limbs}, %#{n+1*@limbs}, %#{n+2*@limbs};\\n\\t\""
            end
            say "\"addc.u32    %#{@limbs-1+0*@limbs}, %#{@limbs-1+1*@limbs}, %#{@limbs-1+2*@limbs};\\n\\t\""
          end
          
          ["dst", "src1", "src2"].each do |var|
            if var == "src2"
              arg_dst = "  "
            else
              arg_dst = ": "
            end
            
            if var == "dst"
              ty = "\"=r\""
            else
              ty = "\"r\""
            end
            
            @limbs.times do |n|
              arg_dst += "#{ty} (#{var}->x[#{n}])"
              arg_dst += ", " unless ((n == @limbs - 1) && (var != "src1"))
            end
            say arg_dst
          end
          say ": \"cc\""
        popi
      say ");"
      popi
      say "#else"
      pushi(4)
        plus_carry = "0"
        say "#{@ul} d = { 0 };"
        @limbs.times do |n|
          say "d->x[#{n}] = (src1->x[#{n}] & 0x7fffffff) + (src2->x[#{n}] & 0x7fffffff) + #{plus_carry};"
          say "uint32_t c#{n} = (src1->x[#{n}] >> 31) + (src2->x[#{n}] >> 31) + (d->x[#{n}] >> 31);"
          say "d->x[#{n}] = (c#{n} << 31) | (d->x[#{n}] & 0x7fffffff);"
          say "c#{n} = c#{n} >> 1;"
          say "dst->x[#{n}] = d->x[#{n}];"
          say ""
          plus_carry = "c#{n}";
        end
      popi
      say "#endif"
      say "return;"
    popi
    say "}"
  end
  
  def gen_sub
    comment "Sub two #{@ul}'s"
    say "inline void #{@ul}_sub(#{@ul} dst, #{@ul} src1, #{@ul} src2) {"
    pushi(4)
      say "#if defined(#{@flag_nvidia})"
      pushi(4)
        say "asm("
        pushi(2)
          # We have 3*@limbs arguments into our inline assembly.
          
          if @bitwidth == 32
            say "\"sub.u32  %#{0+0*@limbs}, %#{0+1*@limbs}, %#{0+2*@limbs};\\n\\t\""
          else
            say "\"sub.cc.u32  %#{0+0*@limbs}, %#{0+1*@limbs}, %#{0+2*@limbs};\\n\\t\""
            (1..@limbs-2).each do |n|
              say "\"subc.cc.u32 %#{n+0*@limbs}, %#{n+1*@limbs}, %#{n+2*@limbs};\\n\\t\""
            end
            say "\"subc.u32    %#{@limbs-1+0*@limbs}, %#{@limbs-1+1*@limbs}, %#{@limbs-1+2*@limbs};\\n\\t\""
          end
          
          ["dst", "src1", "src2"].each do |var|
            if var == "src2"
              arg_dst = "  "
            else
              arg_dst = ": "
            end
            
            if var == "dst"
              ty = "\"=r\""
            else
              ty = "\"r\""
            end
            
            @limbs.times do |n|
              arg_dst += "#{ty} (#{var}->x[#{n}])"
              arg_dst += ", " unless ((n == @limbs - 1) && (var != "src1"))
            end
            say arg_dst
          end
          say ": \"cc\""
        popi
      say ");"
      popi
      say "#else"
      pushi(4)
        minus_borrow = "0"
        say "#{@ul} d = { 0 };"
        @limbs.times do |n|
          say "d->x[#{n}] = (src1->x[#{n}] & 0x7fffffff) - (src2->x[#{n}] & 0x7fffffff) - #{minus_borrow};"
          say "uint32_t b#{n} = (src1->x[#{n}] >> 31) - (src2->x[#{n}] >> 31) - (d->x[#{n}] >> 31);"
          say "d->x[#{n}] = (b#{n} << 31) | (d->x[#{n}] & 0x7fffffff);"
          say "b#{n} = (b#{n} >> 1) & 1;"
          say "dst->x[#{n}] = d->x[#{n}];"
          say ""
          minus_borrow = "b#{n}";
        end
      popi
      say "#endif"
      say "return;"
    popi
    say "}"
  end
  
  # Helper for gen_mul        
  def gen_mul_nvidia(work, visited, carry_in, i, m1, m2)
    if i >= work.length
      return
    end
    
    mjob = work[i].index{|j| j[:src1] == m1 && j[:src2] == m2}
    if mjob == nil
      job = work[i].pop
    else
      job = work[i][mjob]
      work[i].delete_at(mjob)
    end
    # puts "#{i}: carry_in=#{carry_in}  #{job}"
    
    if job == nil
      gen_mul_nvidia(work, visited, false, i+1, m1, m2)
      return
    end
    
    if carry_in
      ins = "madc."
    elsif visited[i]
      ins = "mad."
    else
      ins = "mul."
    end
    
    if job[:mo] == 'low'
      mo = "lo."
    elsif job[:mo] == 'high'
      mo = "hi."
    else
      raise "Unknown job mode #{job[:mo]}"
    end
    
    carry_out = visited[i] && (i+1 < work.length)
    if carry_out
      co = "cc."
    else
      co = ""
    end

    a = "%#{job[:src1]}"
    b = "%#{job[:src2]}"
    if visited[i]
      c = "%#{i}"
    else
      c = "0"
    end
    d = "%#{i}"
    
    if ins == "mul."
      say "\"#{ins}#{mo}#{co}u32 #{d}, #{a}, #{b};\\n\\t\""
    else
      say "\"#{ins}#{mo}#{co}u32 #{d}, #{a}, #{b}, #{c};\\n\\t\""
    end
    
    visited[i] = true
    
    if carry_out
      gen_mul_nvidia(work, visited, true, i+1, job[:src1], job[:src2])
    end
    
    if carry_in
      return
    end
    
    gen_mul_nvidia(work, visited, false, i, job[:src1], job[:src2])
  end

  def gen_mul
    comment "Mul two #{@ul}'s"
    say "inline void #{@ul}_mul(#{@ul} dst, #{@ul} src1, #{@ul} src2) {"
    pushi(4)
      say "#if defined(#{@flag_nvidia})"
      pushi(4)
        say "asm("
        pushi(2)
          # Build the queue of work which must be done
          # Consists of hi- and low- muls
          work = []
          @limbs.times do |i|
            jobs = []
            (0 .. i).each do |j|
              job = { :mo => 'low', :src1 => j+1*@limbs, :src2 => (i-j)+2*@limbs }
              # puts "#{i} #{job}"
              jobs.push(job)
            end
            (0 .. i-1).each do |j|
              job = { :mo => 'high', :src1 => j+1*@limbs, :src2 => (i-j-1)+2*@limbs  }
              # puts "#{i} #{job}"
              jobs.push(job)
            end
            work.push(jobs.reverse)
          end
          
          # Used to track, for each word index, whether or
          # not we've already performed work at that index
          visited = Array.new(work.length, false)
          # Generate the code
          gen_mul_nvidia(work, visited, false, 0, 0, 0)
          
          # The arguments
          ["dst", "src1", "src2"].each do |var|
            if var == "src2"
              arg_dst = "  "
            else
              arg_dst = ": "
            end
            
            if var == "dst"
              ty = "\"=r\""
            else
              ty = "\"r\""
            end
            
            @limbs.times do |n|
              arg_dst += "#{ty} (#{var}->x[#{n}])"
              arg_dst += ", " unless ((n == @limbs - 1) && (var != "src1"))
            end
            say arg_dst
          end
          say ": \"cc\""
        popi
      say ");"
      popi
      say "#else"
      pushi(4)
        if @limbs == 1
          say "dst->x[0] = src1->x[0] * src2->x[0];"
        elsif @limbs == 2
          say "uint64_t d = ((((uint64_t)src1->x[1]) << 32) | src1->x[0]) * ((((uint64_t)src2->x[1]) << 32) | src2->x[0]);"
          say "dst->x[0] = d;"
          say "dst->x[1] = d >> 32;"
        else
          say "#{@ul} d = {0};"
          say ""
          t = 0;
          @limbs.times do |i|
            (0 .. i).each do |j|
              say "uint64_t tmp#{t} = ((uint64_t)src1->x[#{j}]) * ((uint64_t)src2->x[#{i-j}]);"
              say "#{@ul} tmp#{t}_;"
              @limbs.times do |n|
                if n == i
                  say "tmp#{t}_->x[#{n}] = tmp#{t};"
                elsif n == i+1
                  say "tmp#{t}_->x[#{n}] = tmp#{t} >> 32;"
                else
                  say "tmp#{t}_->x[#{n}] = 0;"
                end
              end
              say "#{@ul}_add(d, tmp#{t}_, d);"
              say ""
              t += 1
            end
          end
          @limbs.times do |n|
            say "dst->x[#{n}] = d->x[#{n}];"
          end
        end
      popi
      say "#endif"
      say "return;"
    popi
    say "}"
    say ""
  end
  
  def gen_cmp
    comment "Compare two #{@ul}'s"
    say "inline int #{@ul}_cmp(#{@ul} src1, #{@ul} src2) {"
    pushi(4)
      say "int r = 0;"
      els = ""
      (@limbs - 1).downto(0) do |n|
        say "#{els}if (src1->x[#{n}] > src2->x[#{n}]) r = 1;"
        say "else if (src1->x[#{n}] < src2->x[#{n}]) r = -1;"
        els = "else "
      end
      say "return r;"
    popi
    say "}"
    say ""
  end
  
  def gen_cmp_ui
    comment "Compare a #{@ul} with a uint32_t"
    say "inline int #{@ul}_cmp_ui(#{@ul} src1, uint32_t src2) {"
    pushi(4)
      say "int r = 0;"
      els = ""
      upper_or = ""
      (@limbs - 1).downto(0) do |n|
        if n > 1
          upper_or += "src1->x[#{n}] | "
        elsif n == 1
          say "if (#{upper_or} src1->x[1]) r = 1;"
          els = "else "
        elsif n == 0
          say "#{els}if (src1->x[0] > src2) r = 1;"
          say "else if (src1->x[0] < src2) r = -1;"
        end
        els = "else "
      end
      say "return r;"
    popi
    say "}"
    say ""
  end
  
  def gen_modinit
    comment "Initialize #{@modul}"
    say "inline void #{@modul}_init(#{@modul} n) {"
    say "}"
    say ""
  end
  
  def gen_to_montgomery
    comment "Convert a #{@ul} into Montgomery form"
    say "inline void #{@ul}_to_montgomery(#{@ul} dst, #{@ul} src, #{@modul} mod) {"
    pushi(4)
      say "#{@ul}_modmul(dst, src, mod->rsq, mod);"
    popi
    say "}"
    say ""
  end
  
  def gen_from_montgomery
      comment "Convert a #{@ul} out-of Montgomery form"
      say "inline void #{@ul}_from_montgomery(#{@ul} dst, #{@ul} src, #{@modul} mod) {"
      pushi(4)
        say "#{@ul} one = { 0 };"
        say "one->x[0] = 1;"
        say ""
        say "#{@ul}_modmul(dst, src, one, mod);"
      popi
      say "}"
      say ""
    end
  
  
  def gen_modadd
    comment "Add two #{@ul}'s modulo another"
    say "inline void #{@ul}_modadd(#{@ul} dst, #{@ul} src1, #{@ul} src2, #{@modul} n) {"
    pushi(4)
      say "#{@ul}_add(dst, src1, src2);"
      say "if (#{@ul}_cmp(dst, n->n) >= 0)"
      say "    #{@ul}_sub(dst, dst, n->n);"
    popi
    say "}"
    say ""
  end
  
  def gen_modsub
    comment "Subtract one #{@ul} from another modulo a third"
    say "inline void #{@ul}_modsub(#{@ul} dst, #{@ul} src1, #{@ul} src2, #{@modul} n) {"
    pushi(4)
      say "#{@ul} tr1, tr2;"
      say "#{@ul}_sub(tr1, src1, src2);"
      say "#{@ul}_add(tr2, tr1, n->n);"
      say "if (#{@ul}_cmp(src1, src2) >= 0)"
      say "    #{@ul}_set(dst, tr1);"
      say "else"
      say "    #{@ul}_set(dst, tr2);"
    popi
    say "}"
    say ""
  end
  
  
  def gen_modmul
    comment "Mul two #{@ul}'s modulo a third, followed by Montgomery reduction"
    say "void #{@ul}_modmul(#{@ul} _dst, #{@ul} _src1, #{@ul} _src2, #{@modul} n) {"
    pushi(4)
      say "#if defined(#{@flag_nvidia})"
      pushi(4)
        say "volatile #{@ul} src1;"
        say "volatile #{@ul} src2;"
        say "/* #{@ul}_set(src1, _src1); */"
        @limbs.times do |i|
            say "src1->x[#{i}] = _src1->x[#{i}];"
        end
        say "/* #{@ul}_set(src2, _src2); */"
        @limbs.times do |i|
            say "src2->x[#{i}] = _src2->x[#{i}];"
        end
        say ""
        say "uint32_t q = 0;"
        say "#{@ul} dst = { 0 };"
        say "uint32_t dst_#{@limbs} = 0;"
        say ""
        say "asm("
        pushi(2)
          # Create look-ups for our variables
          arg_pos = 0;
          dst = Array.new
          (0 .. @limbs).each do |i|
            dst[i] = "%#{arg_pos}"
            arg_pos += 1
          end
          
          q = "%#{arg_pos}"
          arg_pos += 1
          
          a = Array.new
          @limbs.times do |i|
            a[i] = "%#{arg_pos}"
            arg_pos += 1
          end
          
          b = Array.new
          @limbs.times do |i|
            b[i] = "%#{arg_pos}"
            arg_pos += 1
          end
          
          modulus = Array.new
          @limbs.times do |i|
            modulus[i] = "%#{arg_pos}"
            arg_pos += 1
          end
          
          mu = "%#{arg_pos}"
          arg_pos += 1
          
          say "/* Compute c_0..#{@limbs-1} for the product a*b, with carry-out to dst_#{@limbs} */"
          @limbs.times do |i|
            # In this loop we will work out a_i, iterating through the b_i
            # We proceed in even/odd fashion
            
            # Iterate through the even j's
            accum = -1
            carry = ""
            sp = " "
            (0 .. @limbs - 1).step(2) do |j|
              o = i+j
              if o < @limbs
                say "\"mad#{carry}.lo.cc.u32#{sp} #{dst[o]}, #{a[i]}, #{b[j]}, #{dst[o]};\\n\\t\"  /* c_#{o} += lo(a_#{i}, b_#{j}) */"
                carry = "c"
                sp = ""
                accum = o
              end
              if o+1 < @limbs
                say "\"mad#{carry}.hi.cc.u32#{sp} #{dst[o+1]}, #{a[i]}, #{b[j]}, #{dst[o+1]};\\n\\t\"  /* c_#{o+1} += hi(a_#{i}, b_#{j}) */"
                carry = "c"
                sp = ""
                accum = o+1
              end
            end
            if accum >= 0
              say "\"addc.u32 #{dst[accum+1]}, #{dst[accum+1]}, 0;\\n\\t\"  /* accum carry in c_#{accum+1} */"
            end
            # Iterate through the odd j's
            accum = -1
            carry = ""
            sp = " "
            (1 .. @limbs - 1).step(2) do |j|
              o = i+j
              if o < @limbs
                say "\"mad#{carry}.lo.cc.u32#{sp} #{dst[o]}, #{a[i]}, #{b[j]}, #{dst[o]};\\n\\t\"  /* c_#{o} += lo(a_#{i}, b_#{j}) */"
                carry = "c"
                sp = ""
                accum = o
              end
              if o+1 < @limbs
                say "\"mad#{carry}.hi.cc.u32#{sp} #{dst[o+1]}, #{a[i]}, #{b[j]}, #{dst[o+1]};\\n\\t\"  /* c_#{o+1} += hi(a_#{i}, b_#{j}) */"
                carry = "c"
                sp = ""
                accum = o+1
              end
            end
            if accum >= 0
              say "\"addc.u32 #{dst[accum+1]}, #{dst[accum+1]}, 0;\\n\\t\"  /* accum carry in c_#{accum+1} */"
            end
          end
          say ""
          
          say "/* Add in the qN's */"
          @limbs.times do |n|
            say "/* n = #{n}... */"
            pushi(2)
              say "/* Compute q = mu * c_#{n} */"
              say "\"mov.u32 #{q}, #{dst[0]};\\n\\t\""
              say "\"mul.lo.u32 #{q}, #{q}, #{mu};\\n\\t\""

              say "/* Update c_#{n} with qN_0 */"
              say "\"mad.lo.cc.u32 #{dst[0]}, #{q}, #{modulus[0]}, #{dst[0]};\\n\\t\"  /* c_#{n} += lo(q, n_0) */"              
              say "/* Shift */"
              @limbs.times do |m|
                say "\"mov.u32 #{dst[m]}, #{dst[m+1]};\\n\\t\"  /* dst_#{m} <- c_#{n+m+1} */"
              end
              say "\"xor.b32 #{dst[@limbs]}, #{dst[@limbs]}, #{dst[@limbs]};\\n\\t\"  /* dst_#{@limbs} <- c_#{n+1+@limbs} */"

              
              say "/* Compute and add-in qN, with carry-out to dst_#{@limbs} */"
              # q*N_j, j even
              accum = -1
              (0 .. @limbs - 1).step(2) do |j|
                if j > 0
                  say "\"madc.lo.cc.u32 #{dst[j-1]}, #{q}, #{modulus[j]}, #{dst[j-1]};\\n\\t\"  /* c_#{n+j} += lo(q, n_#{j}) */"
                  accum = j-1
                end
                say "\"madc.hi.cc.u32 #{dst[j]}, #{q}, #{modulus[j]}, #{dst[j]};\\n\\t\"  /* c_#{n+j+1} += hi(q, n_#{j}) */"
                accum = j
              end
              if accum >= 0
                (accum + 1 .. @limbs).each do |k|
                  if k == @limbs
                    cc = ""
                    sp = "   "
                  else
                    cc = "cc."
                    sp = ""
                  end
                  say "\"addc.#{cc}u32#{sp} #{dst[k]}, #{dst[k]}, 0;\\n\\t\"  /* accum carry in dst_#{k} */"
                end
              end
              # q*N_j, j odd
              accum = -1
              carry = ""
              sp = " "
              (1 .. @limbs - 1).step(2) do |j|
                say "\"mad#{carry}.lo.cc.u32#{sp} #{dst[j-1]}, #{q}, #{modulus[j]}, #{dst[j-1]};\\n\\t\"  /* c_#{j} += lo(q, n_#{j}) */"
                say "\"madc.hi.cc.u32 #{dst[j]}, #{q}, #{modulus[j]}, #{dst[j]};\\n\\t\"  /* c_#{j+1} += hi(q, n_#{j}) */"
                carry = "c"
                sp = ""
                accum = j
              end
              if accum >= 0
                (accum + 1 .. @limbs).each do |k|
                  if k == @limbs
                    cc = ""
                    sp = "   "
                  else
                    cc = "cc."
                    sp = ""
                  end
                  say "\"addc.#{cc}u32#{sp} #{dst[k]}, #{dst[k]}, 0;\\n\\t\"  /* accum carry in dst_#{k} */"
                end
              end
            popi
          end
          say ""
          
          say "/* Compute c_#{@limbs}..#{2*@limbs-1} in the product a*b, storing the result in dst_0..#{@limbs-1}, with carry-out to dst_#{@limbs} */"
          @limbs.times do |i|
            # In this loop we will work out a_i, iterating through the b_i
            # We proceed in even/odd fashion
            
            # Iterate through the even j's
            accum = -1
            carry = ""
            sp = " "
            (0 .. @limbs - 1).step(2) do |j|
              o = i+j
              if o >= @limbs
                say "\"mad#{carry}.lo.cc.u32#{sp} #{dst[o-@limbs]}, #{a[i]}, #{b[j]}, #{dst[o-@limbs]};\\n\\t\"  /* c_#{o} += lo(a_#{i}, b_#{j}) */"
                carry = "c"
                sp = ""
                accum = o
              end
              if o+1 >= @limbs
                say "\"mad#{carry}.hi.cc.u32#{sp} #{dst[o+1-@limbs]}, #{a[i]}, #{b[j]}, #{dst[o+1-@limbs]};\\n\\t\"  /* c_#{o+1} += hi(a_#{i}, b_#{j}) */"
                carry = "c"
                sp = ""
                accum = o+1
              end
            end
            if accum >= 0
              (accum+1 .. 2*@limbs).each do |k|
                if k == 2*@limbs
                  cc = ""
                  sp = "   "
                else
                  cc = "cc."
                  sp = ""
                end
                say "\"addc.#{cc}u32#{sp} #{dst[k-@limbs]}, #{dst[k-@limbs]}, 0;\\n\\t\"  /* accum carry in c_#{k} */"
              end
            end
            # Iterate through the odd j's
            accum = -1
            carry = ""
            sp =" "
            (1 .. @limbs - 1).step(2) do |j|
              o = i+j
              if o >= @limbs
                say "\"mad#{carry}.lo.cc.u32#{sp} #{dst[o-@limbs]}, #{a[i]}, #{b[j]}, #{dst[o-@limbs]};\\n\\t\"  /* c_#{o} += lo(a_#{i}, b_#{j}) */"
                accum = o
                carry = "c"
                sp = ""
              end
              if o+1 >= @limbs
                say "\"mad#{carry}.hi.cc.u32#{sp} #{dst[o+1-@limbs]}, #{a[i]}, #{b[j]}, #{dst[o+1-@limbs]};\\n\\t\"  /* c_#{o+1} += hi(a_#{i}, b_#{j}) */"
                accum = o+1
                carry = "c"
                sp = ""
              end
            end
            if accum >= 0
              (accum+1 .. 2*@limbs).each do |k|
                if k == 2*@limbs
                  cc = ""
                  sp = "   "
                else
                  cc = "cc."
                  sp = ""
                end
                say "\"addc.#{cc}u32#{sp} #{dst[k-@limbs]}, #{dst[k-@limbs]}, 0;\\n\\t\"  /* accum carry in c_#{k} */"
              end
            end
          end
          say ""

          # Destination variables
          dst_str = ": "
          @limbs.times do |i|
            dst_str += "\"+r\" (dst->x[#{i}]), "
          end
          dst_str += "\"+r\" (dst_#{@limbs}), \"+r\" (q)"
          # Source variables
          src_str = ": "
          @limbs.times do |i|
            src_str += "\"r\" (src1->x[#{i}]), "
          end
          src_str += "\n  " + (" " * @indent.last)
          @limbs.times do |i|
            src_str += "\"r\" (src2->x[#{i}]), "
          end
          src_str += "\n  " + (" " * @indent.last)
          @limbs.times do |i|
            src_str += "\"r\" (n->n->x[#{i}]), "
          end
          src_str += "\n  " + (" " * @indent.last) + "\"r\" (n->np)"

          say dst_str
          say src_str
        popi
        say ");"
        say ""
      
        say "/* Reduce as needed */"
        say "if (dst_#{@limbs} || (#{@ul}_cmp(dst, n->n) >= 0))"
        say "    #{@ul}_sub(dst, dst, n->n);"
        say "#{@ul}_set(_dst, dst);"
      popi
      say "#else"
      pushi(4)
        say "/* The pairwise products of the a_i and b_j */"
        @limbs.times do |x|
          @limbs.times do |y|
            say "const uint64_t a_#{x}__b_#{y} = ((uint64_t)_src1->x[#{x}]) * ((uint64_t)_src2->x[#{y}]);"
            say "const uint32_t a_#{x}__b_#{y}_lo = a_#{x}__b_#{y};"
            say "const uint32_t a_#{x}__b_#{y}_hi = a_#{x}__b_#{y} >> 32;"
          end
        end
        say ""
      
        say "/* Limbs of the product C = A*B */"
        (2 * @limbs + 1).times do |x|
          say "uint32_t c_#{x} = 0;"
          say "uint32_t q_#{x} = 0;"
        end
        say ""
        
        say "/* The product of the q_i's with N */"
        @limbs.times do |i|
          @limbs.times do |j|
            say "uint64_t q_#{i}__N_#{j} = 0;"
          end
        end
        say ""
        
        (2 * @limbs).times do |i|
          say "/* Compute c_#{i} */"
          say "{"
          pushi(4)
            say "/* Add the product terms into c_#{i}, accumulating carries in c_#{i+1} */"
            @limbs.times do |x|
              @limbs.times do |y|
                if x+y == i
                  say "c_#{i+1} += ul32_addc(&c_#{i}, &c_#{i}, &a_#{x}__b_#{y}_lo);"
                end
                if (x+y == i-1)
                  say "c_#{i+1} += ul32_addc(&c_#{i}, &c_#{i}, &a_#{x}__b_#{y}_hi);"
                end
              end
            end
            say ""
            say "/* Add the q_i*N's for i < #{i} */"
            i.times do |j|
              if j < @limbs
                if i-j < @limbs
                  say "const uint32_t q_#{j}__N_#{i-j}_lo = q_#{j}__N_#{i-j};"
                  say "c_#{i+1} += ul32_addc(&c_#{i}, &c_#{i}, &q_#{j}__N_#{i-j}_lo);"
                end
                
                if (0 <= i - 1) && (i-j-1 < @limbs)
                  say "const uint32_t q_#{j}__N_#{i-j-1}_hi = q_#{j}__N_#{i-j-1} >> 32;"
                  say "c_#{i+1} += ul32_addc(&c_#{i}, &c_#{i}, &q_#{j}__N_#{i-j-1}_hi);"
                end
              end
            end
            say ""
            if i < @limbs
              say "/* Compute q_#{i} and add its product with N */"
              say "q_#{i} = n->np * c_#{i};"
              @limbs.times do |j|
                say "q_#{i}__N_#{j} = ((uint64_t)q_#{i}) * ((uint64_t)n->n->x[#{j}]);"
              end
              
              say "const uint32_t q_#{i}__N_0_lo = q_#{i}__N_0;"
              say "c_#{i+1} += ul32_addc(&c_#{i}, &c_#{i}, &q_#{i}__N_0_lo);"
            end
          popi
          say "}"
          say ""
        end
  
        say "/* R = C * beta^{-n} */"      
        @limbs.times do |x|
          say "_dst->x[#{x}] = c_#{x + @limbs};"
        end
        say ""
        
        say "/* Reduce as needed */"
        say "if (c_#{2 * @limbs} || (#{@ul}_cmp(_dst, n->n) >= 0))"
        say "    #{@ul}_sub(_dst, _dst, n->n);"
      popi
      say "#endif"
    popi
    say "}"
    say ""
  end
  
  def gen_rshift
    comment "Right-shift a #{@ul} by some number of bits"
    say "inline void #{@ul}_rshift(#{@ul} dst, #{@ul} src, int shift) {"
    @limbs.times do |j|
      if j == @limbs - 1
        say "dst->x[#{j}] = dst->x[#{j}] >> shift;"
      else
        say "dst->x[#{j}] = (src->x[#{j}] >> shift) | (src->x[#{j+1}] << (32 - shift));"
      end
    end
    say "}"
  end
  
  def gen_lshiftw
    comment "Left shift a #{@ul} by some number of words"
    say "inline void #{@ul}_lshiftw(#{@ul} dst, #{@ul} src, int w) {"
    pushi(4)
      #@limbs.times do |j|
      #  say "dst->x[#{j}] = ((#{j}-w) >= 0) ? src->x[#{j}-w] : 0;"
      #end
      (@limbs-1).downto(0) do |j|
        say "dst->x[#{j}] = ((#{j}-w) >= 0) ? src->x[#{j}-w] : 0;"
      end
    popi
    say "}"
    say ""
  end
  
  def gen_mulu32
    comment "Multiply a #{@ul} by a uint32_t"
    say "inline void #{@ul}_mulu32(#{@ul} dst, #{@ul} src, uint32_t x) {"
    pushi(4)
      @limbs.times do |j|
        say "uint64_t x_src_#{j} = ((uint64_t)src->x[#{j}]) * ((uint64_t)x);"
      end
      say ""
      @limbs.times do |j|
        say "dst->x[#{j}] = 0;"
      end
      say ""
      @limbs.times do |j|
        if j == @limbs - 1
          if j % 2 == 0
            say "dst->x[#{j}] += x_src_#{j};"
          else
            say "dst->x[#{j}] += x_src_#{j} >> 32;"
          end
        else
          say "*(uint64_t*)(&dst->x[#{j}]) += x_src_#{j};"
        end
      end
    popi
    say "}"
    say ""
  end
  
  def genAll
    @outFile = File.open(@out_fname, 'w')
    puts "Generating #{@out_fname}"
    say "/*"
    say " * AUTOGENERATED tcarstens January 2014"
    say " */"
    say "#ifndef __UL#{@bw}_0__"
    say "#define __UL#{@bw}_0__"
    say ""
    say "#include \"../stdint.hl\""
    say "#include \"../rng.hl\""
    say ""
    say ""
    
    gen_type
    vspace
    
    gen_setters
    gen_set_ui
    gen_get_ui
    vspace
    
    gen_rand
    vspace
    
    gen_cmp
    gen_cmp_ui
    vspace
    
    gen_add
    gen_sub
    gen_mul
    vspace
    
    gen_modinit
    gen_modadd
    gen_modsub
    gen_modmul
    gen_to_montgomery
    gen_from_montgomery
    vspace
    
    gen_rshift
    vspace
    
    gen_lshiftw
    gen_mulu32
    vspace
    say "#endif"
    
    @outFile.close
  end
end

class OclHigherGenerator
  def initialize(bitwidth)
    @bitwidth = bitwidth
    @name = "ul#{@bitwidth}"
    @limbs = bitwidth/32

    raise "Requires @bitwidth = #{@bitwidth} be divisible by 32" unless (@bitwidth % 32) == 0
    
    @ul    = "#{@name}"
    @modul = "mod#{@bitwidth}"
    
    @flag_nvidia = "UL_NVIDIA"
    
    @out_fname = "#{Out_dir_ocl_ul}/#{@ul}_1.hl"
    
    @indent = [0]
  end
  
  def pushi(i)
    @indent.push(@indent.last + i)
  end
  
  def popi
    @indent.pop
  end
  
  def say(s)
    ind = " " * @indent.last
    @outFile.write("#{ind}#{s}\n")
  end
  
  def vspace
    say("")
    say("")
    say("")
  end
  
  def comment(c)
    say "/*"
    say " * #{c}"
    say " */"
  end
  
  def gen_modset
    comment "Set the modulus for a #{@modul}"
    say "inline void #{@modul}_set(#{@modul} dst, #{@ul} n) {"
    pushi(4)
      say "uint32_t tmp = 0;"
      say "#{@ul}_set(dst->n, n);"
      say "tmp = 2 + n->x[0];"
      say "tmp = tmp * (2 + n->x[0] * tmp);"
      say "tmp = tmp * (2 + n->x[0] * tmp);"
      say "tmp = tmp * (2 + n->x[0] * tmp);"
      say "tmp = tmp * (2 + n->x[0] * tmp);"
      say "dst->np = tmp;"
      say ""
      say "#{@ul} one = { 0 };"
      say "one->x[0] = 1;"
      say ""
      say "#{@ul}_modmul(dst->rsq, one, one, dst); /* dst->rsq <- 1/r */"
      say "#{@ul}_modmul(dst->rsq, dst->rsq, one, dst); /* dst->rsq <- 1/rsq */"
      say "#{@ul}_modinv(dst->rsq, dst->rsq, dst->n); /* dst->rsq <- rsq */"
    popi
    say "}"
  end
  
  def gen_divrem
    comment "Compute the quotient with remainder of two #{@ul}'s (q = a/b_, r = a%b_, resp.)"
    say "void #{@ul}_divrem(#{@ul} Q_, #{@ul} R_, #{@ul} A_in, #{@ul} B_in) {"
    pushi(4)
      say "ul#{@bitwidth+32} Q = { 0 };"
      say "#{@ul} R = { 0 };"
      say "if (#{@ul}_cmp(A_in, B_in) < 0) {"
      pushi(4)
        say "#{@ul}_set(Q_, (struct #{@ul}_s *)Q);"
        say "#{@ul}_set(R_, A_in);"
        say "return;"
      popi
      say "}"
      say ""
      say "/* Locate the most significant word of B_in           */"
      say "int n = #{@limbs}; /* B_in->x[n-1] is the MSW. */"
      say "while ((n > 0) && (!B_in->x[n-1]))"
      say "    n--;"
      say "/* NB: if n == 0, then B_in = 0, and we've been asked */"
      say "/* to comptue a div by 0. Thus we assume n > 0, which */"
      say "/* means (for instance) that n-1 is a valid index     */"
      say "/* into B_in.                                         */"
      say ""
      say "/* Check to see if B_in is normalized, meaning that   */"
      say "/* B_in->x[n-1] >= 2^31.                              */"
      say "unsigned int k = clz(B_in->x[n-1]);"
      say ""
      say "/* Normalize A_in and B_in. Note that B_in's MSW is   */"
      say "/* the same as B's (normalization does not change it) */"
      say "/* but the same is not necessarily true of A and A_in. */"
      ["A", "B"].each do |v|
        say "ul#{@bitwidth+32} #{v} = { 0 };"
        @limbs.downto(0) do |k|
          if k == @limbs
            l = "0"
          else
            l = "#{v}_in->x[#{k}] << k"
          end
          if k == 0
            r = "0"
          else
            r = "(k > 0) ? (#{v}_in->x[#{k-1}] >> (32-k)) : 0"
          end
          say "#{v}->x[#{k}] = (#{l}) | (#{r});"
        end
        say ""
      end
      say "/* Now we compute m, the difference between the MSW of */"
      say "/* A and B.                                            */"
      say "int m = #{@limbs+1} - n;"
      say "while ((m > 0) && (!A->x[n+m-1]))"
      say "    m--;"
      say "/* We know that m >= 0 since A_in >= B_in, which we    */"
      say "/* determined above.                                   */"
      say ""
      say "/* Compute Q->x[m]: */"
      say "{"
      pushi(4)
        say "ul#{@bitwidth+32} beta_m_B = { 0 };"
        say "ul#{@bitwidth+32}_lshiftw(beta_m_B, B, m);"
        say ""
        say "if (ul#{@bitwidth+32}_cmp(A, beta_m_B) >= 0) {"
        pushi(4)
          say "Q->x[m] = 1;"
          say "ul#{@bitwidth+32}_sub(A, A, beta_m_B);"
        popi
        say "}"
        say "else"
        say "    Q->x[m] = 0;"
      popi
      say "}"
      say ""
      say "/* Compute the rest of Q: */"
      say "for (int j = m-1; j >= 0; j--) {"
      pushi(4)
        say "uint64_t q_star = ( (((uint64_t)A->x[n+j]) << 32) | ((uint64_t)A->x[n+j-1]) )/((uint64_t)B->x[n-1]);"
        say "Q->x[j] = (q_star < ((uint64_t)0x00000000ffffffff)) ? q_star : 0xffffffff;"
        say ""
        say "/* A <- A - q_j * beta^j * B */"
        say "{"
        pushi(4)
          say "ul#{@bitwidth+32} qjbj_B = { 0 };"
          say "ul#{@bitwidth+32}_lshiftw(qjbj_B, B, j);"
          say "ul#{@bitwidth+32}_mulu32(qjbj_B, qjbj_B, Q->x[j]);"
          say "ul#{@bitwidth+32}_sub(A, A, qjbj_B);"
        popi
        say "}"
        say ""
        say "/* If A < 0, roll back Q->x[j] and adjust A: */"
        say "while (A->x[#{@limbs}] & (1 << 31)) {"
        pushi(4)
          say "Q->x[j]--;"
          say "ul#{@bitwidth+32} bj_B = { 0 };"
          say "ul#{@bitwidth+32}_lshiftw(bj_B, B, j);"
          say "ul#{@bitwidth+32}_add(A, A, bj_B);"
        popi
        say "}"
      popi
      say "}"
      say ""
      say "/* The remainder is now the de-normalized value of A: */"
      @limbs.times do |k|
        say "R->x[#{k}] = ((k > 0) ? (A->x[#{k+1}] << (32-k)) : 0) | (A->x[#{k}] >> k);"
      end
      say "#{@ul}_set(Q_, (struct #{@ul}_s *)Q);"
      say "#{@ul}_set(R_, R);"
    popi
    say "}"
    say ""
  end
  
  def gen_modinv
    comment "Compute the inverse of a #{@ul} modulo another"
    say "void #{@ul}_modinv(#{@ul} dst, #{@ul} src, #{@ul} n) {"
    pushi(4)
      say "#{@ul} zero = { 0 };"
      say "#{@ul} u = { 0 };"
      say "u->x[0] = 1;"
      say "#{@ul} w = { 0 };"
      say "#{@ul} b = { 0 };"
      say "#{@ul} c = { 0 };"
      say "#{@ul}_set(b, src);"
      say "#{@ul}_set(c, n);"
      say ""
      say "while (#{@ul}_cmp(c, zero) != 0) {"
      pushi(4)
        say "#{@ul} q;"
        say "#{@ul} r;"
        say ""
        say "#{@ul}_divrem(q, r, b, c);"
        say "#{@ul}_set(b, c);"
        say "#{@ul}_set(c, r);"
        say ""
        say "#{@ul} temp = { 0 };"
        say "#{@ul}_mul(temp, q, w);"
        say "#{@ul}_sub(temp, u, temp);"
        say ""
        say "#{@ul}_set(u, w);"
        say "#{@ul}_set(w, temp);"
      popi
      say "}"
      say ""
      say "/* TODO! Here we are testing if u < 0. This version passes tests, */"
      say "/* but I'm skeptical that it is correct. I think the right thing  */"
      say "/* is to use ul#{@bitwidth+32}'s and check the higher word there. */"
      say "if (u->x[#{@limbs-1}] & (1 << 31))"
      say "    #{@ul}_add(u, u, n);"
      say "#{@ul}_set(dst, u);"
    popi
    say "}"
  end
  
  def genAll
    @outFile = File.open(@out_fname, 'w')
    puts "Generating #{@out_fname}"
    say "/*"
    say " * AUTOGENERATED tcarstens January 2014"
    say " */"
    say "#ifndef __UL#{@bitwidth}_1__"
    say "#define __UL#{@bitwidth}_1__"
    say ""
    say "#include \"#{@ul}_0.hl\""
    say "#include \"ul#{@bitwidth+32}_0.hl\""
    say ""
    say ""

    gen_divrem
    # gen_modinv
    say "int #{@ul}_modinv(#{@ul} dst, #{@ul} src, #{@ul} n);"
    vspace
    
    gen_modset
    vspace
    
    say "#endif"
  
    @outFile.close
  end
end

(32 .. 256).step(32).each do |bitwidth|
  OclTestGenerator.new(bitwidth).genAll
  HostTestGenerator.new(bitwidth).genAll

  # OclLasGenerator.new(bitwidth).genAll
  HostLasGenerator.new(bitwidth).genAll

  OclDefGenerator.new(bitwidth).genAll
  OclBaseGenerator.new(bitwidth).genAll
  OclHigherGenerator.new(bitwidth).genAll
  OclHeaderGenerator.new(bitwidth, true).genAll
end

OclBaseGenerator.new(256+32).genAll
OclHeaderGenerator.new(256+32, false).genAll


